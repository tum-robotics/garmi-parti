"""
This module defines interfaces for teleoperation.
These include the most generic `Interface` class but also
more device specific interfaces such as `PandaInterface` etc.
The `Interface` class defines the interface as used by the
networking modules, by implementing the abstract methods, you
will have a teleoperator compatible with the `garmi_parti.teleoperation`
module. Implementations of these interfaces are generally referred
to as `teleoperators`. We think of server-side teleoperators as followers
and client-side teleoperators as leaders.
"""

from __future__ import annotations

import abc
import csv
import datetime
import logging
import pathlib
import threading
import time

import numpy as np
import panda_py
from panda_py import libfranka

from . import containers

_logger = logging.getLogger("teleoperation.interface")


class Interface(abc.ABC):
    """
    General teleoperator interface definition.
    """

    @abc.abstractmethod
    def pre_teleop(self) -> bool:
        """
        Executed after connection has been established
        but before teleoperation.
        """

    @abc.abstractmethod
    def start_teleop(self) -> None:
        """
        Executed after `pre_teleop` was executed on both ends.
        """

    @abc.abstractmethod
    def pause(self, end_effector: str = "") -> None:
        """
        Executed when a pause was requested.
        """

    @abc.abstractmethod
    def unpause(self, end_effector: str = "") -> None:
        """
        Executed when an unpause was requested.
        """

    @abc.abstractmethod
    def post_teleop(self) -> bool:
        """
        Executed after teleoperation has finished.
        """

    @abc.abstractmethod
    def get_command(self) -> bytes:
        """
        Get the command to be sent over the network.
        """

    @abc.abstractmethod
    def set_command(self, command: bytes) -> None:
        """
        Called when a new command has been received over the network.

        Args:
          command: Received command
        """

    @abc.abstractmethod
    def get_sync_command(self) -> bytes:
        """
        Called by teleoperation clients to be sent to the server
        for synchronization. This call happens after a connection
        is established but before teleoperation starts,
        i.e. between the `pre_teleop` and `start_teleop` hooks.
        """

    @abc.abstractmethod
    def set_sync_command(self, command: bytes, end_effector: str = "") -> None:
        """
        Called by the network server. The `command` argument of this
        method is generated by `get_sync_command` on the client side.
        Use this mechanism to synchronize teleoperators before
        teleoperation begins.

        Args:
          command: Received synchronization command
        """

    @abc.abstractmethod
    def open(self, end_effector: str = "") -> None:
        """
        This method is called by server (followers) and requested via
        network from clients (leaders). Use this method to open end effectors
        specified by `end_effector`. Refer to `garmi_parti.teleoperation.client.open`
        for the network call.
        Args:
          end_effector: End effector name
        """

    @abc.abstractmethod
    def close(self, end_effector: str = "") -> None:
        """
        This method is called by server (followers) and requested via
        network from clients (leaders). Use this method to close end effectors
        specified by `end_effector`. Refer to `garmi_parti.teleoperation.client.close`
        for the network call.
        Args:
          end_effector: End effector name
        """


class PandaInterface(Interface, abc.ABC):
    """
    Generic teleoperation interface for Panda robots.
    """

    def __init__(
        self, params: containers.TeleopParams, has_gripper: bool = False
    ) -> None:
        self.panda = containers.TeleopContainer(
            arm=panda_py.Panda(params.hostname, name="panda"),
            gripper=self.init_gripper(params.hostname, has_gripper),
            params=params,
            transform=params.transform,
            transform_inv=params.transform.inv(),
        )
        self.q_idle = params.q_idle
        self.q_teleop = params.q_teleop
        self.move_arm(self.q_idle)

    def move_arm(self, joint_positions: containers.JointPositions | None) -> None:
        """
        Move the robot arm into the given joint positions.
        """
        if joint_positions is not None:
            self.panda.arm.move_to_joint_position(
                joint_positions.positions, self.panda.params.speed_factor
            )

    def init_gripper(self, hostname: str, has_gripper: bool) -> libfranka.Gripper:
        """
        Connect to the hardware and initialize gripper.
        """
        if has_gripper:
            gripper = libfranka.Gripper(hostname)
            gripper.move(0.08, 0.2)
            return gripper
        return None

    def open(self, end_effector: str = "") -> None:
        del end_effector
        if self.panda.gripper is not None:
            self.panda.gripper.stop()
            self.panda.gripper.grasp(0.08, 0.2, 60, 0.08, 0.08)

    def close(self, end_effector: str = "") -> None:
        del end_effector
        if self.panda.gripper is not None:
            self.panda.gripper.stop()
            self.panda.gripper.grasp(0.0, 0.2, 60, 0.08, 0.08)

    def pre_teleop(self) -> bool:
        self.move_arm(self.q_teleop)
        self._pre_teleop(self.panda)
        return True

    def start_teleop(self) -> None:
        self._start_teleop(self.panda)

    def post_teleop(self) -> bool:
        self._post_teleop(self.panda)
        self.move_arm(self.q_idle)
        return True

    def _pre_teleop(self, container: containers.TeleopContainer) -> None:
        container.arm.set_default_behavior()

        # set collision behavior
        container.arm.get_robot().set_collision_behavior(
            [100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0],
            [100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0],
            [100.0, 100.0, 100.0, 100.0, 100.0, 100.0],
            [100.0, 100.0, 100.0, 100.0, 100.0, 100.0],
        )

    def _start_teleop(self, container: containers.TeleopContainer) -> None:
        container.reinitialize()
        container.arm.start_controller(container.controller)

    def _post_teleop(self, container: containers.TeleopContainer) -> None:
        container.arm.stop_controller()

    def get_sync_command(self) -> bytes:
        return b""

    def set_sync_command(self, command: bytes, end_effector: str = "") -> None:
        pass

    def fdir(self, container: containers.TeleopContainer) -> None:
        """
        Fault detection, isolation, and recovery.
        """
        try:
            container.arm.raise_error()
        except RuntimeError as e:
            _logger.error(e)
            container.arm.recover()
            container.arm.start_controller(container.controller)


class TwoArmPandaInterface(PandaInterface, abc.ABC):
    """
    Common base class for two-arm teleoperators.
    """

    # pylint: disable=W0231
    def __init__(
        self,
        left: containers.TeleopParams,
        right: containers.TeleopParams,
        has_left_gripper: bool = False,
        has_right_gripper: bool = False,
    ) -> None:
        self.left = containers.TeleopContainer(
            arm=panda_py.Panda(left.hostname, name="left"),
            gripper=self.init_gripper(left.hostname, has_left_gripper),
            params=left,
            transform=left.transform,
            transform_inv=left.transform.inv(),
        )
        self.right = containers.TeleopContainer(
            arm=panda_py.Panda(right.hostname, name="right"),
            gripper=self.init_gripper(right.hostname, has_right_gripper),
            params=right,
            transform=right.transform,
            transform_inv=right.transform.inv(),
        )
        self.two_arm_q_idle = containers.TwoArmJointPositions(
            left=left.q_idle, right=right.q_idle
        )
        self.two_arm_q_teleop = containers.TwoArmJointPositions(
            left=left.q_teleop, right=right.q_teleop
        )
        self.move_arms(self.two_arm_q_idle)

    def open(self, end_effector: str = "") -> None:
        gripper = getattr(self, end_effector).gripper
        if gripper is not None:
            gripper.stop()
            gripper.grasp(0.08, 0.2, 60, 0.08, 0.08)

    def close(self, end_effector: str = "") -> None:
        gripper = getattr(self, end_effector).gripper
        if gripper is not None:
            gripper.stop()
            gripper.grasp(0.0, 0.2, 60, 0.08, 0.08)

    def move_arms(self, joint_positions: containers.TwoArmJointPositions) -> None:
        """
        Move both arms to the given joint positions simultaneously.
        """
        threads = []

        if joint_positions.left is not None:
            t_left = threading.Thread(
                target=self.left.arm.move_to_joint_position,
                args=(joint_positions.left.positions, self.left.params.speed_factor),
            )
            threads.append(t_left)
            t_left.start()

        if joint_positions.right is not None:
            t_right = threading.Thread(
                target=self.right.arm.move_to_joint_position,
                args=(joint_positions.right.positions, self.right.params.speed_factor),
            )
            threads.append(t_right)
            t_right.start()

        for thread in threads:
            thread.join()

    def pre_teleop(self) -> bool:
        self.move_arms(self.two_arm_q_teleop)
        self._pre_teleop(self.left)
        self._pre_teleop(self.right)
        return True

    def start_teleop(self) -> None:
        self._start_teleop(self.left)
        self._start_teleop(self.right)

    def post_teleop(self) -> bool:
        self._post_teleop(self.left)
        self._post_teleop(self.right)
        self.move_arms(self.two_arm_q_idle)
        return True


class TwoArmLogger:
    """
    Logs the robot states of two Panda robots.
    """

    def __init__(
        self,
        interface: TwoArmPandaInterface,
        frequency: float = 50,
        log_directory: str = "./logs",
    ) -> None:
        self.log_directory = log_directory
        self._ensure_directory_exists()
        self.log_file = self._create_log_file()
        self._interface = interface
        self._frequency = frequency
        self._running = True
        self._thread = threading.Thread(target=self._run)
        self._thread.start()

    def _ensure_directory_exists(self) -> None:
        if not pathlib.Path(self.log_directory).exists():
            pathlib.Path(self.log_directory).mkdir(parents=True)

    def _create_log_file(self) -> pathlib.Path:
        current_datetime = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        return pathlib.Path(self.log_directory) / f"log_{current_datetime}.csv"

    def _run(self) -> None:
        with self.log_file.open(mode="a", newline="") as file:
            writer = csv.writer(file)
            while self._running:
                time.sleep(1 / self._frequency)
                left = self._interface.left.arm.get_state()
                right = self._interface.right.arm.get_state()
                row = np.r_[
                    left.O_T_EE,
                    left.O_F_ext_hat_K,
                    right.O_T_EE,
                    right.O_F_ext_hat_K,
                    time.time(),
                ]
                writer.writerow(row)

    def stop(self) -> None:
        """
        Stop the logger's thread.
        """
        self._running = False
        self._thread.join()
